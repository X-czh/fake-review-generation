import torch
import torch.nn as nn
import torch.nn.functional as F


class Generator(nn.Module):
    """Generator """

    def __init__(self, vocab_size, embedding_dim, hidden_dim, use_cuda):
        super(Generator, self).__init__()
        self.hidden_dim = hidden_dim
        self.use_cuda = use_cuda
        self.embed = nn.Embedding(vocab_size, embedding_dim)
        self.lstm = nn.LSTM(embedding_dim, hidden_dim)
        self.fc = nn.Linear(hidden_dim, vocab_size)
        self.init_params()

    def forward(self, x):
        """
        Embeds input and applies LSTM on the entire sequence.

        Inputs: x
            - x: (batch_size, seq_len), sequence of tokens generated by generator
        Outputs: out
            - out: (batch_size, seq_len, vocab_size), lstm output prediction
        """
        h0, c0 = self.init_hidden(x.size(0))
        emb = self.embed(x) # batch_size * seq_len * emb_dim 
        emb = emb.permute(1, 0, 2) # seq_len * batch_size * emb_dim
        out, _ = self.lstm(emb, (h0, c0)) # out: seq_len * batch_size * hidden_dim
        out = out.permute(1, 0, 2) # batch_size * seq_len * hidden_dim
        out = F.log_softmax(self.fc(out.view(-1, self.hidden_dim)), dim=2) # batch_size * seq_len * vocab_size
        return out

    def step(self, x, h, c):
        """
        Embeds input and applies LSTM one token at a time (seq_len = 1).

        Inputs: x, h, c
            - x: (batch_size, 1), sequence of tokens generated by generator
            - h: (1, batch_size, hidden_dim), lstm hidden state
            - c: (1, batch_size, hidden_dim), lstm cell state
        Outputs: out, h, c
            - out: (batch_size, 1, vocab_size), lstm output prediction
            - h: (1, batch_size, hidden_dim), lstm hidden state
            - c: (1, batch_size, hidden_dim), lstm cell state 
        """
        emb = self.embed(x) # batch_size * 1 * emb_dim
        emb = emb.permute(1, 0, 2) # 1 * batch_size * emb_dim
        out, (h, c) = self.lstm(emb, (h, c)) # out: 1 * batch_size * hidden_dim
        out = out.permute(1, 0, 2) # batch_size * 1 * hidden_dim
        out = F.log_softmax(self.fc(out.view(-1, self.hidden_dim)), dim=2) # batch_size * 1 * vocab_size
        return out, h, c

    def sample(self, batch_size, seq_len, x=None):
        """
        Samples the network and returns a batch of samples of length seq_len.
        Outputs: out
            - out: (batch_size * seq_len)
        """
        h, c = self.init_hidden(batch_size)
        samples = []
        if x is None:
            x = torch.zeros(batch_size, 1, dtype=torch.int64, requires_grad=True)
            if self.use_cuda:
                x = x.cuda()
            for i in range(seq_len):
                out, h, c = self.step(x, h, c)
                x = out.multinomial(1)
                samples.append(x)
        else:
            given_len = x.size(1)
            lis = x.chunk(x.size(1), dim=1)
            for i in range(given_len):
                out, h, c = self.step(lis[i], h, c)
                samples.append(lis[i])
            x = out.multinomial(1)
            for i in range(given_len, seq_len):
                samples.append(x)
                out, h, c = self.step(x, h, c)
                x = out.multinomial(1)
        out = torch.cat(samples, dim=1)
        return out

    def init_hidden(self, batch_size=1):
        h = torch.zeros(1, batch_size, self.hidden_dim, requires_grad=True)
        c = torch.zeros(1, batch_size, self.hidden_dim, requires_grad=True)
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.uniform_(-0.05, 0.05)
